# ObjectBus
基于C++11开发的消息总线
## 1.1 消息总线介绍

基于消息总线技术可以有效解决对象之间复杂的关联关系，对象间只通过消息联系，不需要通过直接依赖或者关联。消息总线将复杂的对象关系简化，将我们从处理复杂的对象关系网中解放出来。

在消息总线中，对象都是通过消息来联系的，消息即对象的关系，只需要在消息总线中管理这些消息，而不用关心具体的对象之间有关联。

## 1.2 关键技术

##### （1）通用的消息定义

消息总线技术的本质是让所有对象都通过消息联系，因此需要定义一种通用的消息格式，让所有对象都接受。

消息总线中的消息应该是所有对象都能解析的消息，对象的联系到最后都是通过函数的调用实现的。通用的消息类型完整定义如下：主题+泛型函数的签名，其中主题可以是字符串或者其他类型，只有对该主题感兴趣的接收者才会收到消息；泛型函数用来确定哪些接受者具备接收该消息的能力。这里将泛型函数std::function<R (Args...)>，用它来表示通用的消息格式。泛型函数中Args..是一个可变参数模板，代表任意个数、任意类型的参数，表示所有的入参，std::function<R (Args...)>就能表示所有的可调用对象。

为了便于理解，下面举个栗子：

假设有一个图形编辑软件，其中包含多个图形对象，如矩形、圆形和三角形。这个软件使用消息总线来实现对象之间的通信。

1. **消息总线初始化：**
	- 在软件启动时，消息总线被初始化。各个图形对象注册到消息总线，以便它们能够收发消息。
2. **消息的发送：**
	- 用户在界面上点击了一个按钮，选择了“放大”操作。这个操作生成一个消息，比如"ZoomIn"消息，并包含了放大的参数。
3. **消息总线传递消息：**
	- 生成的"ZoomIn"消息被发送到消息总线。消息总线负责将这个消息传递给所有注册的图形对象。
4. **图形对象解析消息：**
	- 各个图形对象都订阅了消息总线，它们会检查接收到的消息。只有支持放大操作的图形对象才会解析这个消息。
5. **通过函数调用实现操作：**
	- 如果某个图形对象支持"ZoomIn"消息，它会调用自身的"zoomIn"函数来实现放大操作。这里的函数调用是最终的实际行为。

消息总线使得对象之间的通信更加松散耦合。图形对象不需要直接调用彼此的函数，而是通过消息总线传递消息，最终通过函数调用来实现实际的操作。大白话就是：比如A如果不用消息机制，肯定需要调用某个具有放大功能的对象的放大函数，A.Zoomln，这样就耦合了，现在有了消息机制，不需要直接调用了。

这段话描述了一个通用的消息类型的定义，其中消息包含两个主要部分：主题和泛型函数的签名。这种消息设计的目的是使得只对特定主题感兴趣的接收者才会接收到相关消息，并通过泛型函数来确定哪些接收者有能力处理这个消息。

==主题+泛型函数的签名==

**假设有一个消息类型：**

- **主题：** "NewTask"
- **泛型函数的签名：** `void (*)(Task)`

这个消息的主题是"NewTask"，而泛型函数的签名表示接收到这个消息的处理函数应该接受一个类型为`Task`的参数，并且不返回任何值。这里的`Task`可以是一个自定义的数据结构，表示一个任务。

**例子：**

1. **发送消息：**
	- 系统中的某个组件生成一个新的任务并希望通知所有对"NewTask"主题感兴趣的接收者。
2. **接收者注册：**
	- 有两个对象A和B注册到系统中，它们对"NewTask"主题感兴趣。
3. **消息传递：**
	- 系统将"NewTask"消息发送到消息总线。
4. **接收者判断：**
	- 接收者A和B都检查收到的消息，因为它们对"NewTask"主题感兴趣。
5. **泛型函数的调用：**
	- 接收者A和B调用各自的泛型函数，传递消息中的任务作为参数。例如：
		- 接收者A的处理函数：`void HandleNewTask(Task taskA)`
		- 接收者B的处理函数：`void HandleNewTask(Task taskB)`

通过这样的设计，系统可以在运行时动态地注册和取消注册对特定主题感兴趣的接收者，而每个接收者只需要实现相应主题的泛型函数即可。

##### （2）消息的注册

让所有对象都可以注册感兴趣的消息。

消息的注册是告诉总线该对象对某种消息感兴趣，希望收到某种主题和类型的消息。总线内部维护一个消息列表，当需要发送消息时，会遍历消息列表，从中查找是否有合适的消息和消息接收者，找到合适的接收者之后再广播消息。

1. **消息注册：**
	- 当一个对象希望接收某种类型和主题的消息时，它会向消息总线注册。这意味着该对象对特定的消息感兴趣，希望在这个主题下接收相关类型的消息。
2. **消息总线的消息列表：**
	- 消息总线内部维护一个消息列表，这个列表记录了所有已经注册的对象以及它们感兴趣的消息主题和类型。每个注册对象都与它感兴趣的消息相关联。
3. **发送消息：**
	- 当系统需要发送一个消息时，它会将消息发送到消息总线。这个消息包括主题和消息内容（类型）。
4. **消息广播：**
	- 消息总线收到消息后，会遍历它的消息列表，查找所有对这个主题感兴趣的对象。这是通过检查每个对象的注册信息来实现的。
5. **找到合适的接收者：**
	- 在遍历过程中，消息总线找到了对这个主题感兴趣的一个或多个对象。这些对象被认为是合适的接收者。
6. **广播消息：**
	- 消息总线将消息广播给找到的所有合适的接收者。每个接收者都会收到这个消息，并根据自己注册时定义的处理函数来处理消息。

发送者不需要直接了解接收者的身份和实现细节。它只需要将消息发送到消息总线，而消息总线负责将消息传递给对该消息感兴趣的对象。

由于消息类型是由一个消息主题和泛型函数组成，topic + std::function<R (Args...)>，这个泛型函数可能是所有的可调用对象，如普通函数、成员函数、函数对象、std::function和lamda表达式，因此消息总线的注册接口要能接收所有函数语义的对象。第一步是将个中可调用对象转换为std::function，在转换为统一的消息格式之后，消息总线将这些消息保存起来，以便在合适的时候分发，只有注册了特定主题和消息的接收者对象才能收到分发消息。

1. **消息类型的组成：**
	- 消息类型由一个消息主题（topic）和一个泛型函数（`std::function<R (Args...)>`）组成。这里的泛型函数表示消息的处理函数，它可以是任何可调用对象，如普通函数、成员函数、函数对象、`std::function`和Lambda表达式。
2. **注册接口的设计：**
	- 为了实现通用性，消息总线的注册接口需要能够接收所有函数语义的对象。这意味着注册接口需要处理不同种类的可调用对象，并将它们转换为统一的消息格式，即`std::function<R (Args...)>`。
3. **转换为统一格式：**
	- 在注册时，消息总线会将各种可调用对象（普通函数、成员函数、函数对象、`std::function`、Lambda等）转换为统一的消息格式，即`std::function<R (Args...)>`。这个转换的目的是为了将不同类型的处理函数抽象成一致的接口，方便后续消息的处理和分发。
4. **保存消息：**
	- 注册时转换完毕后，消息总线将这些消息保存起来。它可能会维护一个消息列表或映射，记录每个注册对象感兴趣的主题和相应的处理函数。
5. **消息分发：**
	- 当系统需要发送消息时，消息总线会遍历保存的消息列表，找到对应主题的处理函数，并将消息传递给这些处理函数。只有注册了特定主题和消息的接收者对象才能收到分发的消息。

通过这个机制，消息总线实现了对不同种类可调用对象的统一处理和分发。这种设计使得系统中的各个部分能够更加灵活地注册和处理消息，而不受特定类型的函数语义限制。

如何将各种可调用对象转换为std::function?

lambda表达式转换为std::function

lambda表达式是一个匿名类，内部有operator()调用符，可以通过function_traits获取lamda的operator()类型，之后再转换为std::function

转换代码见lambda_to_function.cpp。

###### 保存注册消息

C++目前没有容器能存放不同的类型，如果要将不同类型的对象保存到一个容器中，需要将这些不同类型的对象的类型擦除，这里通过Any类型来擦除对象的类型。消息总线内部用来保存消息的容器为std::unordered_multimap<string, Any> m_map，键为主题 + 消息类型的字符串，值为消息对象。消息注册的代码实现在save_registered_messages.cpp

对于非成员函数的可调用对象，可以先通过to_function将其转换为std::function类型，之后再将std::function转换为Any，擦除类型，最后将消息key和消息对象保存起来。

##### （3）消息的分发

通过消息总线分发消息，让所有接收者都能收到并处理信息。

主题对象希望接收者对象收到消息时，就会通过消息总线发送消息，消息本质上是std::function，（在C++中，`std::function` 是一个通用的可调用对象的封装，可以包含函数指针、函数对象、Lambda 表达式等，因此消息可以是任何可调用的东西。）在发送这个消息之前，就要先创建这个消息，在创建消息之后再发送，消息总线会查找内部的容器，看哪些对象对这个消息感兴趣，只有注册了该消息的对象才能收到消息。

在发送消息的时候需要提供两个参数，第一个参数是形参列表，用来生成具体的消息，消息总线会根据这个消息来查找哪些对象注册了消息，如果找到了就分发出去，这样接收者就会收到消息并处理。第二个参数是消息的主题，用来限定只有注册了该主题的对象才能收到消息，默认没有主题，所有注册了该消息的对象都能收到消息。

##### 消息总线的设计思想

消息总线融合了观察者模式和中介者模式，还通过类型擦除技术擦除消息的类型，使得我们能够管理所有类型的消息。

观察者模式和中介者模式都是软件设计中常见的设计模式，用于解决对象之间的通信和协作问题。

1. **观察者模式（Observer Pattern）：**
	- **定义：** 观察者模式定义了一种一对多的依赖关系，使得当一个对象状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式涉及两种类型的对象：观察者和主题。主题（也称为被观察者）维护一组观察者，当主题的状态发生变化时，它会通知所有观察者，使它们能够自动更新。
	- **关键角色：**
		- **Subject（主题）：** 维护一组观察者，提供注册和删除观察者的接口，并在状态改变时通知观察者。
		- **Observer（观察者）：** 定义一个更新接口，以便在主题状态发生改变时接收通知。
	- **适用场景：** 当一个对象的改变需要同时改变其他对象，而且不知道有多少对象需要改变时，就应该考虑使用观察者模式。
2. **中介者模式（Mediator Pattern）：**
	- **定义：** 中介者模式定义了一个对象，该对象封装了一系列对象之间的交互方式。中介者使对象之间的耦合性减小，可以独立改变它们之间的交互。
	- **关键角色：**
		- **Mediator（中介者）：** 定义一个接口用于与各个同事对象通信，充当中介者的角色。
		- **Colleague（同事）：** 各个同事类知道中介者对象，通过中介者对象与其他同事对象通信。
	- **适用场景：** 当一组对象之间存在复杂的交互，并且对象之间的通信方式需要灵活变化时，可以考虑使用中介者模式。
3. **融合观察者模式和中介者模式：**
	- **观察者模式和中介者模式的共性：** 都涉及对象之间的协作和通信。
	- **融合的优势：** 将观察者模式和中介者模式结合，可以在观察者模式的基础上引入一个中介者，进一步降低观察者之间的耦合性，同时中介者能够更好地管理和协调观察者之间的交互。

在描述中，还提到了使用了类型擦除技术，这通常是通过使用泛型编程或虚函数等机制来实现。这样做的目的是为了实现消息总线可以处理各种类型的消息，使得消息的具体类型对于消息总线来说是不可知的，从而提高了消息总线的灵活性。

消息总线最大的目的是集中管理所有对象之间的交互关系，让这些对象的关系解耦并容易管理。由于消息总线是一个中介者，因此，主题和观察者不必相互依赖，二者通过消息总线连接起来，甚至都不知道对方的存在。另外，消息总线维护的消息体是所有类型的可调用对象，没有对象之间的直接调用 ，更没有接口继承，主题和观察者之间仅仅通过某种类型的消息联系起来，这个消息简单说就是返回值类型+形参类型：R（Args...）
![image](https://github.com/cquptxx-SANGFOR/ObjectBus/assets/85086873/f8f10bee-38aa-473f-9884-0fa3553e186c)
![image](https://github.com/cquptxx-SANGFOR/ObjectBus/assets/85086873/bda3ccfa-b191-4a50-8b81-0b0412085ff1)

消息总线通过类型擦除技术，使得消息总线可以接收所有类型的函数注册。


























